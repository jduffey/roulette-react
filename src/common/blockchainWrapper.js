import { ethers } from "ethers";

const provider = new ethers.providers.JsonRpcProvider("http://localhost:8545");

// TODO: retrieve addresses from file generated by initialization script so they aren't hardcoded
const FIRST_PLAYER_ADDRESS = process.env.REACT_APP_FIRST_PLAYER_ADDRESS || "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266";
const SECOND_PLAYER_ADDRESS = process.env.REACT_APP_SECOND_PLAYER_ADDRESS || "0x70997970C51812dc3A010C7d01b50e0d17dc79C8";
const THIRD_PLAYER_ADDRESS = process.env.REACT_APP_THIRD_PLAYER_ADDRESS || "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC";
const HOUSE_ADDRESS = process.env.REACT_APP_HOUSE_ADDRESS || "0x90F79bf6EB2c4f870365E785982E1f101E93b906";
// Contract addresses from the latest deployment
const TOKEN_CONTRACT_ADDRESS = process.env.REACT_APP_TOKEN_CONTRACT_ADDRESS || "0x057ef64E23666F000b34aE31332854aCBd1c8544";
const RANDOMNESS_PROVIDER_CONTRACT_ADDRESS = process.env.REACT_APP_RANDOMNESS_PROVIDER_CONTRACT_ADDRESS || "0x261D8c5e9742e6f7f1076Fa1F560894524e19cad";
const ROULETTE_CONTRACT_ADDRESS = process.env.REACT_APP_ROULETTE_CONTRACT_ADDRESS || "0xCE3478A9E0167a6Bc5716DC39DbbbfAc38F27623";

async function executeWager(address) {
    console.log('üîç executeWager called with address:', address);
    console.log('üîç Using ROULETTE_CONTRACT_ADDRESS:', ROULETTE_CONTRACT_ADDRESS);
    console.log('üîç Using HOUSE_ADDRESS:', HOUSE_ADDRESS);
    
    try {
        const contract = new ethers.Contract(
            ROULETTE_CONTRACT_ADDRESS,
            ["function executeWager(address)"],
            provider.getSigner(HOUSE_ADDRESS)
        );
        console.log('üîç Contract instance created successfully');
        
        console.log('üîç Calling executeWager on contract...');
        const tx = await contract.executeWager(address);
        console.log('üîç executeWager transaction sent:', tx.hash);
        return tx;
    } catch (error) {
        console.error('‚ùå Error in executeWager:', error);
        console.error('‚ùå Error details:', {
            message: error.message,
            code: error.code,
            reason: error.reason,
            data: error.data,
            stack: error.stack
        });
        throw error;
    }
}

async function placeBet(betName, betAmount) {
    console.log('üîç placeBet called with:', { betName, betAmount });
    console.log('üîç Using ROULETTE_CONTRACT_ADDRESS:', ROULETTE_CONTRACT_ADDRESS);
    
    try {
        const contract = new ethers.Contract(
            ROULETTE_CONTRACT_ADDRESS,
            ["function placeBet(string,uint256)"],
            provider.getSigner()
        );
        console.log('üîç Contract instance created for placeBet');
        
        const betAmountWei = ethers.utils.parseEther(betAmount.toString());
        console.log('üîç Converted bet amount to Wei:', betAmountWei.toString());
        
        console.log('üîç Calling placeBet on contract...');
        const tx = await contract.placeBet(betName, betAmountWei);
        console.log('üîç placeBet transaction sent:', tx.hash);
        return tx;
    } catch (error) {
        console.error('‚ùå Error in placeBet:', error);
        console.error('‚ùå Error details:', {
            message: error.message,
            code: error.code,
            reason: error.reason,
            data: error.data,
            stack: error.stack
        });
        throw error;
    }
}

async function clearBets() {
    const contract = new ethers.Contract(
        ROULETTE_CONTRACT_ADDRESS,
        ["function clearBets()"],
        provider.getSigner()
    );
    const tx = await contract.clearBets();
    return tx;
}

async function removeBet(betIndex) {
    const contract = new ethers.Contract(
        ROULETTE_CONTRACT_ADDRESS,
        ["function removeBet(uint256)"],
        provider.getSigner()
    );
    const tx = await contract.removeBet(betIndex);
    return tx;
}

async function getPendingBets(address) {
    console.log('üîç getPendingBets called with address:', address);
    console.log('üîç Using ROULETTE_CONTRACT_ADDRESS:', ROULETTE_CONTRACT_ADDRESS);
    
    try {
        const contract = new ethers.Contract(
            ROULETTE_CONTRACT_ADDRESS,
            ["function getPendingBets(address) view returns (tuple(bytes32 betType, uint256 betAmount)[])"],
            provider.getSigner()
        );
        console.log('üîç Contract instance created for getPendingBets');
        
        console.log('üîç Calling getPendingBets on contract...');
        const bets = await contract.getPendingBets(address);
        console.log('üîç Raw bets from contract:', bets);
        
        const convertedBets = bets.map(bet => {
            // Convert bytes32 betType back to original bet name
            const betTypeHash = bet.betType;
            console.log('üîç Processing bet with hash:', betTypeHash);
            let betName = "UNKNOWN";
            
            // Check for known bet types by comparing hashes
            const betTypes = [
                "RED", "BLACK", "EVEN", "ODD", "FIRST_DOZEN", "SECOND_DOZEN", "THIRD_DOZEN",
                "FIRST_COLUMN", "SECOND_COLUMN", "THIRD_COLUMN", "LOW_NUMBERS", "HIGH_NUMBERS",
                "STRAIGHT_UP_0", "STRAIGHT_UP_00"
            ];
            
            for (const type of betTypes) {
                const typeHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(type));
                console.log(`üîç Comparing ${type}: ${typeHash} === ${betTypeHash}?`);
                if (typeHash === betTypeHash) {
                    betName = type;
                    console.log('üîç Found match:', betName);
                    break;
                }
            }
            
            // Check for straight up bets 1-36
            if (betName === "UNKNOWN") {
                for (let i = 1; i <= 36; i++) {
                    const straightUpBet = `STRAIGHT_UP_${i}`;
                    const straightUpHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(straightUpBet));
                    if (straightUpHash === betTypeHash) {
                        betName = straightUpBet;
                        console.log('üîç Found straight up bet match:', betName);
                        break;
                    }
                }
            }
            
            const result = {
                betName: betName,
                betAmount: parseFloat(ethers.utils.formatEther(bet.betAmount))
            };
            console.log('üîç Converted bet:', result);
            return result;
        });
        
        console.log('üîç Final converted bets:', convertedBets);
        return convertedBets;
    } catch (error) {
        console.error('‚ùå Error in getPendingBets:', error);
        console.error('‚ùå Error details:', {
            message: error.message,
            code: error.code,
            reason: error.reason,
            data: error.data,
            stack: error.stack
        });
        throw error;
    }
}

async function getTotalPendingBetAmount(address) {
    const contract = new ethers.Contract(
        ROULETTE_CONTRACT_ADDRESS,
        ["function getTotalPendingBetAmount(address) view returns (uint256)"],
        provider.getSigner()
    );
    const amount = await contract.getTotalPendingBetAmount(address);
    return parseFloat(ethers.utils.formatEther(amount));
}

async function getEthBalance(address) {
    const signer = provider.getSigner(address);
    const balance = await signer.getBalance();
    return ethers.utils.formatEther(balance);
}

async function getBlock() {
    const block = await provider.getBlock("latest");
    return block;
}

async function getTokenBalance(address) {
    const token = new ethers.Contract(
        TOKEN_CONTRACT_ADDRESS,
        ["function balanceOf(address) view returns (uint)"],
        provider.getSigner(HOUSE_ADDRESS)
    );
    const balance = await token.balanceOf(address);
    return ethers.utils.formatEther(balance);
}

async function getPlayerAllowance(address) {
    const token = new ethers.Contract(
        TOKEN_CONTRACT_ADDRESS,
        ["function allowance(address, address) view returns (uint)"],
        provider.getSigner(HOUSE_ADDRESS)
    );
    const allowance = await token.allowance(address, ROULETTE_CONTRACT_ADDRESS);
    return ethers.utils.formatEther(allowance);
}

async function getPlayerNumberCompletionSetsCounter(address) {
    const contract = new ethers.Contract(
        ROULETTE_CONTRACT_ADDRESS,
        ["function getPlayerNumberCompletionSetsCounter(address) public view returns (uint256)"],
        provider.getSigner(address)
    );
    const count = await contract.getPlayerNumberCompletionSetsCounter(address);
    return count;
}

async function getPlayerNumberCompletionSetCurrent(address) {
    const contract = new ethers.Contract(
        ROULETTE_CONTRACT_ADDRESS,
        ["function getPlayerNumberCompletionSetCurrent(address) public view returns (uint256[])"],
        provider.getSigner(address)
    );
    const currentSet = await contract.getPlayerNumberCompletionSetCurrent(address);
    return currentSet.map((bigIntNumber) => parseInt(bigIntNumber.toString(), 10));;
}

let _cachedTokenSymbol = null;
async function getTokenSymbol() {
    if (_cachedTokenSymbol) return _cachedTokenSymbol;
    const token = new ethers.Contract(
        TOKEN_CONTRACT_ADDRESS,
        ["function symbol() view returns (string)"],
        provider
    );
    _cachedTokenSymbol = await token.symbol();
    return _cachedTokenSymbol;
}

const rouletteContractEvents = new ethers.Contract(
    ROULETTE_CONTRACT_ADDRESS,
    [
        'event ExecutedWager(address indexed, uint256, uint256, uint256)',
        'event BetPlaced(address indexed, bytes32, uint256)',
        'event BetCleared(address indexed)',
        'event BetRemoved(address indexed, uint256, uint256)',
    ],
    provider
);

async function placeMultipleBets(betNames, betAmounts) {
    console.log('üîç placeMultipleBets called with:', { betNames, betAmounts });
    console.log('üîç Using ROULETTE_CONTRACT_ADDRESS:', ROULETTE_CONTRACT_ADDRESS);
    
    try {
        const contract = new ethers.Contract(
            ROULETTE_CONTRACT_ADDRESS,
            ["function placeMultipleBets(string[],uint256[])", "event BetPlaced(address,string,uint256)"],
            provider.getSigner()
        );
        console.log('üîç Contract instance created for placeMultipleBets');
        
        // Convert betAmounts to Wei (treating amounts as ETH, not dollars)
        const betAmountsWei = betAmounts.map(amount => ethers.utils.parseEther(amount.toString()));
        console.log('üîç Converted bet amounts to Wei:', betAmountsWei.map(w => w.toString()));
        
        console.log('üîç Calling placeMultipleBets on contract...');
        const tx = await contract.placeMultipleBets(betNames, betAmountsWei);
        console.log('üîç placeMultipleBets transaction sent:', tx.hash);
        return tx;
    } catch (error) {
        console.error('‚ùå Error in placeMultipleBets:', error);
        console.error('‚ùå Error details:', {
            message: error.message,
            code: error.code,
            reason: error.reason,
            data: error.data,
            stack: error.stack
        });
        throw error;
    }
}

async function getRouletteContractTokenBalance() {
    console.log('üîç getRouletteContractTokenBalance called');
    console.log('üîç Using TOKEN_CONTRACT_ADDRESS:', TOKEN_CONTRACT_ADDRESS);
    console.log('üîç Using ROULETTE_CONTRACT_ADDRESS:', ROULETTE_CONTRACT_ADDRESS);
    
    try {
        const token = new ethers.Contract(
            TOKEN_CONTRACT_ADDRESS,
            ["function balanceOf(address) view returns (uint)"],
            provider.getSigner(HOUSE_ADDRESS)
        );
        const balance = await token.balanceOf(ROULETTE_CONTRACT_ADDRESS);
        const balanceEth = ethers.utils.formatEther(balance);
        console.log('üîç Roulette contract token balance:', balanceEth);
        return balanceEth;
    } catch (error) {
        console.error('‚ùå Error getting Roulette contract token balance:', error);
        throw error;
    }
}

async function fundRouletteContract(amount) {
    console.log('üîç fundRouletteContract called with amount:', amount);
    console.log('üîç Using TOKEN_CONTRACT_ADDRESS:', TOKEN_CONTRACT_ADDRESS);
    console.log('üîç Using ROULETTE_CONTRACT_ADDRESS:', ROULETTE_CONTRACT_ADDRESS);
    console.log('üîç Using HOUSE_ADDRESS:', HOUSE_ADDRESS);
    
    try {
        const token = new ethers.Contract(
            TOKEN_CONTRACT_ADDRESS,
            ["function transfer(address,uint256)"],
            provider.getSigner(HOUSE_ADDRESS)
        );
        
        const amountWei = ethers.utils.parseEther(amount.toString());
        console.log('üîç Transferring', amountWei.toString(), 'tokens to Roulette contract...');
        
        const tx = await token.transfer(ROULETTE_CONTRACT_ADDRESS, amountWei);
        console.log('üîç Fund transaction sent:', tx.hash);
        
        const receipt = await tx.wait();
        console.log('üîç Fund transaction confirmed in block:', receipt.blockNumber);
        
        // Check new balance
        const newBalance = await getRouletteContractTokenBalance();
        console.log('üîç Roulette contract new balance:', newBalance);
        
        return receipt;
    } catch (error) {
        console.error('‚ùå Error funding Roulette contract:', error);
        console.error('‚ùå Error details:', {
            message: error.message,
            code: error.code,
            reason: error.reason,
            data: error.data,
            stack: error.stack
        });
        throw error;
    }
}

export {
    executeWager,
    placeBet,
    clearBets,
    removeBet,
    getPendingBets,
    getTotalPendingBetAmount,
    getEthBalance,
    getBlock,
    getTokenBalance,
    getPlayerAllowance,
    getPlayerNumberCompletionSetsCounter,
    getPlayerNumberCompletionSetCurrent,
    FIRST_PLAYER_ADDRESS,
    SECOND_PLAYER_ADDRESS,
    THIRD_PLAYER_ADDRESS,
    HOUSE_ADDRESS,
    TOKEN_CONTRACT_ADDRESS,
    ROULETTE_CONTRACT_ADDRESS,
    RANDOMNESS_PROVIDER_CONTRACT_ADDRESS,
    getTokenSymbol,
    rouletteContractEvents,
    placeMultipleBets,
    getRouletteContractTokenBalance,
    fundRouletteContract,
};
